[["index.html", "Wildlife Presence Using Trail Cameras 1 Remote sensing and wildlife 1.1 SNAPSHOT USA 1.2 Study area 1.3 Data description", " Wildlife Presence Using Trail Cameras Riley Robenstein 2025-12-08 1 Remote sensing and wildlife Use of remote sensing in wildlife research has become increasingly prevalent, particularly with trail cameras. Trail cameras can provide information about wildlife presence and absence when human observations are unavailable or may disturb wildlife activity and presence. Continued collection of data with trail cameras can provide spatial and temporal trends of larger wildlife. The SNAPSHOT USA project contains several years of camera trap data across the US available for public use (Rooney et al. 2025b). Data were collected using un-baited cameras and identified through Wildlife Insights. The objective of this project is to become familiar with trail camera data to assess wildlife presence and activity. This will ultimately help in future data collection using trail cameras and acoustic recording units deployed and point count surveys conducted in the University of Idaho Experimental Forest to assess how deadwood structures may influence wildlife presence and activity. This file assists in building a database and cleaning and visualizing trail camera data. 1.1 SNAPSHOT USA SNAPSHOT USA is a national project where camera trap surveys are conducted across all 50 US states annually from September-October to estimate wildlife abundance and distributions (Rooney et al. 2025a). This project primarily focuses on mammalian species, with large birds also included. SNAPSHOT USA’s protocol provides a solid base for community science, and various organizations across the country collaborate to produce these spatial and temporal wildlife data. Some contributors have provided data outside the standard collection period, so the 2019-2023 data span from August 1-December 29 (Rooney et al. 2025a). Each collaborator is required to deploy a camera array made up of a minimum of eight un-baited cameras. The SNAPSHOT USA protocol requires at least 400 camera trap-nights between September and October per year for each camera array (Rooney et al. 2025a). 1.2 Study area My focal area included a total of 15 trail camera sites in Idaho, Washington, and Oregon (Figure 1). Figure 1. Camera array locations and Bailey’s ecoregions of the US from 2019-2023 (Rooney 2024). Darker points represent locations that fall within Idaho, Washington and Oregon and size correlates to the number of years surveyed. Colored polygons represent different ecoregions. 1.3 Data description I subsetted these data to only include cameras deployed in Idaho, Washington and Oregon. Data consisted of camera arrays, camera locations, general habitat characteristics, deployment periods, image sequences, and taxonomic information across various levels for species identification (Rooney et al. 2025b). Further information regarding camera array locations and ecoregions were added for camera arrays (Rooney 2024). References Rooney, B. 2024. Years of data collected by camera arrays. &lt;https://public.tableau.com/app/profile/brigit.rooney/viz/YearsofDataCollectedbyCameraArrays/Sheet6&gt;. Rooney, B., R. Kays, M. V. Cove, A. Jensen, B. R. Goldstein, C. Pate, P. Castiblanco, M. E. Abell, J. Adley, B. Agenbroad, et al. 2025a. SNAPSHOT USA 2019-2023: The first five years of data from a coordinated camera trap survey of the united states. Global Ecology and Biogeography 34:e13941. &lt;https://onlinelibrary.wiley.com/doi/full/10.1111/geb.13941&gt;. Rooney, B., W. McShea, R. Kays, and M. Cove. 2025b. SNAPSHOT USA 2019-2023: the first five years of data from a coordinated camera trap survey of the United States [Dataset]. Dryad. &lt;https://datadryad.org/dataset/doi:10.5061/dryad.k0p2ngfhn&gt;. "],["database-creation-and-population.html", "2 Database creation and population 2.1 Load packages and create and connect to database 2.2 PROJECT_NAME table 2.3 CAMERA_ARRAY table 2.4 SITE_NAME table 2.5 DEPLOYMENT table 2.6 SEQUENCE table 2.7 DETECTION table 2.8 Check database", " 2 Database creation and population Trail camera data were distributed across six .csv files in the processed_data folder to optimize storage and data manipulation. I created a relational database with R and SQL to easily navigate these data (Figure 2). Note that the header of each box corresponds to the name of each table. The database can be reproduced with the code in sections 2.1-2.8. Figure 2. Entity relationship diagram of relational database structure. 2.1 Load packages and create and connect to database Load the packages DBI and RSQLite required to connect R and SQLite. Use install.packages() if the packages are not installed. library(DBI) library(RSQLite) Connect to the database file. A database file will be created if the code has not previously been executed. wlf_cam_db &lt;- dbConnect(drv = RSQLite::SQLite(), &quot;../database/wlf_cam.db&quot;) 2.2 PROJECT_NAME table The project_name table includes the following variables: project_id (primary key), project_name, and year, where project_id is a unique identifier for each unique project by year, project name is the respective project name, and year is the year data were captured. 2.2.1 Create project_name table Create the table in SQLite. dbExecute(conn = wlf_cam_db, statement = &quot;CREATE TABLE project_name ( project_id varchar(10) PRIMARY KEY NOT NULL UNIQUE, project_name varchar(35), year numeric(4) CHECK (year IN (&#39;2019&#39;, &#39;2020&#39;, &#39;2021&#39;, &#39;2022&#39;, &#39;2023&#39;)) );&quot;) 2.2.2 Populate project_name table Populate this database table with the .csv file after checking the column names correspond. # Read in project_name.csv file project_name_csv &lt;- read.csv(&quot;../processed_data/project_name.csv&quot;) # Get .csv column names colnames(project_name_csv) # Get database field names dbListFields(wlf_cam_db, &quot;project_name&quot;) # Append .csv into SQLite table dbWriteTable(conn = wlf_cam_db, name = &quot;project_name&quot;, value = project_name_csv, append = TRUE) 2.3 CAMERA_ARRAY table The camera_array table includes the following variables: array_name (primary key), state, years_surveyed, ecoregion, array_lat, and array_long, where array_name is a unique identifier for each camera trap array, state is the US state where the array was located, years_surveyed is the number of years an array has image sequence data from, ecoregion is based on Bailey’s ecoregions (Bailey 2016 as cited in Rooney et al. 2025) and array_lat and array_long are the approximate latitude and longitude coordinates (decimal degrees WGS 84) for the respective array array. 2.3.1 Create camera_array table Create the table in SQLite. dbExecute(conn = wlf_cam_db, statement = &quot;CREATE TABLE camera_array ( array_name varchar(20) PRIMARY KEY NOT NULL UNIQUE, state varchar(2), years_surveyed numeric(1), ecoregion varchar(20), array_lat numeric(10, 10), array_long numeric(10, 10) );&quot;) 2.3.2 Populate camera_array table Populate this database table with the .csv file after checking the column names correspond. # Read in camera_array.csv file camera_array_csv &lt;- read.csv(&quot;../processed_data/camera_array.csv&quot;) # Get .csv column names colnames(camera_array_csv) # Get database field names dbListFields(wlf_cam_db, &quot;camera_array&quot;) # Append .csv into SQLite table dbWriteTable(conn = wlf_cam_db, name = &quot;camera_array&quot;, value = camera_array_csv, append = TRUE) 2.4 SITE_NAME table The site_name table includes the following variables: site_id (primary key), array_name (foreign key), and development_level, where site_id is a unique identifier for each site, array_name corresponds to the array_name in camera_array, and development_level is classified as wild, rural, suburban, or urban. 2.4.1 Create site_name table Create the table in SQLite. dbExecute(conn = wlf_cam_db, statement = &quot;CREATE TABLE site_name ( site_id varchar(50) PRIMARY KEY NOT NULL UNIQUE, array_name varchar(50), development_level varchar(10) CHECK (development_level IN (&#39;Wild&#39;, &#39;Rural&#39;, &#39;Urban&#39;, &#39;Suburban&#39;)), FOREIGN KEY (array_name) REFERENCES camera_array(array_name) );&quot;) 2.4.2 Populate site_name table Populate this database table with the .csv file after checking the column names correspond. # Read in site_name.csv file site_name_csv &lt;- read.csv(&quot;../processed_data/site_name.csv&quot;) # Get .csv column names colnames(site_name_csv) # Get database field names dbListFields(wlf_cam_db, &quot;site_name&quot;) # Append .csv into SQLite table dbWriteTable(conn = wlf_cam_db, name = &quot;site_name&quot;, value = site_name_csv, append = TRUE) 2.5 DEPLOYMENT table The deployment table includes the following variables: deployment_id (primary key), site_id (foreign key), project_id (foreign key). start_date, end_date, survey_nights, latitude, longitude, habitat, and feature type, where deployment_id is a unique identifier for each camera deployment, site_id corresponds to the site_id in site_name, project_id corresponds to the project_id in project_name, start_date is the date (YYYY-MM-DD) when the camera was deployed, end_date is the date (YYYY-MM-DD) when the camera was retrieved, survey_nights is number of nights the camera was at the site, latitude and longitude are geographic coordinates (decimal degrees WGS 84) between 21.3558 to 59.4526 and -157.7496 to -68.6116, respectively, habitat is classified as forest, grassland, or anthropogenic, and feature type indicates potential features at the camera’s deployment site. 2.5.1 Create deployment table Create the table in SQLite. dbExecute(conn = wlf_cam_db, statement = &quot;CREATE TABLE deployment ( deployment_id varchar(60) PRIMARY KEY NOT NULL UNIQUE, site_id varchar(50), project_id varchar(10), start_date text, end_date text, survey_nights numeric (3), latitude numeric(10, 10), longitude numeric(10, 10), habitat varchar(15), feature_type varchar(15), FOREIGN KEY (site_id) REFERENCES site_name(site_id) FOREIGN KEY (project_id) REFERENCES project_name(project_id) );&quot;) 2.5.2 Populate deployment table Populate this database table with the .csv file after checking the column names correspond. # Read in deployment.csv file deployment_csv &lt;- read.csv(&quot;../processed_data/deployment.csv&quot;) # Get .csv column names colnames(deployment_csv) # Get database field names dbListFields(wlf_cam_db, &quot;deployment&quot;) Before populating the table, note the discrepancy in names of variables. ## [1] &quot;deployment_id&quot; &quot;site_id&quot; &quot;project_id&quot; &quot;lat&quot; ## [5] &quot;long&quot; &quot;start&quot; &quot;end&quot; &quot;survey_nights&quot; ## [9] &quot;habitat&quot; &quot;feature_type&quot; ## [1] &quot;deployment_id&quot; &quot;site_id&quot; &quot;project_id&quot; &quot;start_date&quot; ## [5] &quot;end_date&quot; &quot;survey_nights&quot; &quot;latitude&quot; &quot;longitude&quot; ## [9] &quot;habitat&quot; &quot;feature_type&quot; Edit the .csv column names to fit those of the database first. # Edit .csv column names colnames(deployment_csv) &lt;- c(&quot;deployment_id&quot;, &quot;site_id&quot;, &quot;project_id&quot;, &quot;latitude&quot;, &quot;longitude&quot;, &quot;start_date&quot;, &quot;end_date&quot;, &quot;survey_nights&quot;, &quot;habitat&quot;, &quot;feature_type&quot;) # Check .csv column names again colnames(deployment_csv) ## [1] &quot;deployment_id&quot; &quot;site_id&quot; &quot;project_id&quot; &quot;latitude&quot; ## [5] &quot;longitude&quot; &quot;start_date&quot; &quot;end_date&quot; &quot;survey_nights&quot; ## [9] &quot;habitat&quot; &quot;feature_type&quot; Now that the column names match, populate the deployment table. # Append .csv into SQLite table dbWriteTable(conn = wlf_cam_db, name = &quot;deployment&quot;, value = deployment_csv, append = TRUE) 2.6 SEQUENCE table The sequence table includes the following variables: sequence_id (primary key), deployment_id (foreign key), start_time, and end_time, where sequence_id is a unique identifier for each photo sequence captured within one minute of a camera trigger, deployment_id corresponds to the deployment_id in deployment, start_time is the beginning of the one-minute photo sequence, and end_time is the end of the one-minute photo sequence. 2.6.1 Create sequence table Create the table in SQLite. dbExecute(conn = wlf_cam_db, statement = &quot;CREATE TABLE sequence ( sequence_id varchar(15) PRIMARY KEY NOT NULL UNIQUE, deployment_id varchar(60), start_time text, end_time text, FOREIGN KEY (deployment_id) REFERENCES deployment(deployment_id) );&quot;) 2.6.2 Populate sequence table Populate this database table with the .csv file after checking the column names correspond. # Read in sequence.csv file sequence_csv &lt;- read.csv(&quot;../processed_data/sequence.csv&quot;) # Get .csv column names colnames(sequence_csv) # Get database field names dbListFields(wlf_cam_db, &quot;sequence&quot;) # Append .csv into SQLite table dbWriteTable(conn = wlf_cam_db, name = &quot;sequence&quot;, value = sequence_csv, append = TRUE) 2.7 DETECTION table The detection table includes the following variables: detection_id (primary key), sequence_id (foreign key), class, order, family, genus, species, common_name, age, sex, and group_number, where detection_id is a unique identifier for each wildlife detection, sequence_id corresponds to the sequence_id in sequence, class is the taxonomic class identified for the wildlife detection, order is the taxonomic order identified for the wildlife detection, family is the taxonomic family identified for the wildlife detection, genus is the taxonomic genus identified for the wildlife detection, species is the taxonomic species identified for the wildlife detection, common_name is the common name identified for the wildlife detection, age is classified as juvenile or adult, sex is classified as male or female, and group_number is the number of individuals in the image sequence with that respective taxonomic identification. 2.7.1 Create detection table Create the table in SQLite. dbExecute(conn = wlf_cam_db, statement = &quot;CREATE TABLE detection ( detection_id varchar(15) PRIMARY KEY NOT NULL UNIQUE, sequence_id varchar(15), class varchar(15), &#39;order&#39; varchar(20), family varchar(20), genus varchar (15), species varchar(15), common_name varchar(30), age varchar(10), sex varchar(10), group_number numeric(2), FOREIGN KEY (sequence_id) REFERENCES sequence(sequence_id) );&quot;) 2.7.2 Clean detection table The detection .csv file has missing values and formatting is inconsistent. To ensure they are compatible with SQLite and R, load the .csv file and convert all missing values to ‘NA’. Make formatting consistent for the variables age and sex. # Read in detection.csv file detection_csv &lt;- read.csv(&quot;../processed_data/detection.csv&quot;) # Convert &#39; &#39; or &#39;Unknown&#39; values to blank (&#39;&#39;) detection_csv[detection_csv == &quot; &quot; | detection_csv == &quot;Unknown&quot; | detection_csv == &quot;unknown&quot;] &lt;- NA # Make formatting consistent detection_csv$age[detection_csv$age == &quot;adult&quot;] &lt;- &quot;Adult&quot; detection_csv$age[detection_csv$age == &quot;juvenile&quot;] &lt;- &quot;Juvenile&quot; detection_csv$sex[detection_csv$sex == &quot;male&quot;] &lt;- &quot;Male&quot; detection_csv$sex[detection_csv$sex == &quot;female&quot;] &lt;- &quot;Female&quot; 2.7.3 Populate detection table Populate this database table with the .csv file after checking the column names correspond. # Get .csv column names colnames(detection_csv) # Get database field names dbListFields(wlf_cam_db, &quot;detection&quot;) # Append .csv into SQLite table dbWriteTable(conn = wlf_cam_db, name = &quot;detection&quot;, value = detection_csv, append = TRUE) 2.8 Check database Run the following code to ensure the data were loaded into the tables properly. # List table names dbListTables(wlf_cam_db) ## [1] &quot;camera_array&quot; &quot;deployment&quot; &quot;detection&quot; &quot;project_name&quot; &quot;sequence&quot; ## [6] &quot;site_name&quot; # project_name table dbGetQuery(wlf_cam_db, &quot;SELECT * FROM project_name LIMIT 5;&quot;) ## project_id project_name year ## 1 ssusa19 Snapshot USA 2019 2019 ## 2 ssusa20 Snapshot USA 2020 2020 ## 3 ssusa21 Snapshot USA 2021 2021 ## 4 ssusa22 Snapshot USA 2022 2022 ## 5 ssusa23 Snapshot USA 2023 2023 # camera_array table dbGetQuery(wlf_cam_db, &quot;SELECT * FROM camera_array LIMIT 5;&quot;) ## array_name state years_surveyed ecoregion array_lat array_long ## 1 Galena ID 1 Temperate Steppe 43.86 -114.65 ## 2 Hailey ID 1 Temperate Steppe 43.56 -114.47 ## 3 SunValley ID 1 Temperate Steppe 43.70 -114.22 ## 4 OregonStateUni OR 5 Marine 44.42 -123.46 ## 5 Forrester OR 2 Temperate Desert 45.29 -118.56 # site_name table dbGetQuery(wlf_cam_db, &quot;SELECT * FROM site_name LIMIT 5;&quot;) ## site_id array_name development_level ## 1 OR_Forest_Forrester_21_loc_01dup Forrester Wild ## 2 OR_Forest_Forrester_21_loc_02 Forrester Wild ## 3 OR_Forest_Forrester_21_loc_03 Forrester Wild ## 4 OR_Forest_Forrester_21_loc_04 Forrester Wild ## 5 OR_Forest_Forrester_21_loc_05 Forrester Wild # deployment table dbGetQuery(wlf_cam_db, &quot;SELECT * FROM deployment LIMIT 5;&quot;) ## deployment_id site_id ## 1 OR_Forest_Forrester_21_dep_01 OR_Forest_Forrester_21_loc_01dup ## 2 OR_Forest_Forrester_21_dep_02 OR_Forest_Forrester_21_loc_02 ## 3 OR_Forest_Forrester_21_dep_03 OR_Forest_Forrester_21_loc_03 ## 4 OR_Forest_Forrester_21_dep_04 OR_Forest_Forrester_21_loc_04 ## 5 OR_Forest_Forrester_21_dep_05 OR_Forest_Forrester_21_loc_05 ## project_id start_date end_date survey_nights latitude longitude ## 1 Snapshot USA 2021 9/1/2021 11/24/2021 84 45.30501 -118.6071 ## 2 Snapshot USA 2021 9/1/2021 11/24/2021 84 45.30404 -118.5949 ## 3 Snapshot USA 2021 9/1/2021 11/5/2021 65 45.30509 -118.5822 ## 4 Snapshot USA 2021 9/1/2021 11/5/2021 65 45.30507 -118.5695 ## 5 Snapshot USA 2021 9/1/2021 10/28/2021 57 45.30468 -118.5566 ## habitat feature_type ## 1 Forest Trail game ## 2 Forest Trail game ## 3 Forest Trail game ## 4 Forest Trail game ## 5 Forest Road dirt # sequence table dbGetQuery(wlf_cam_db, &quot;SELECT * FROM sequence LIMIT 5;&quot;) ## sequence_id deployment_id start_time end_time ## 1 sewa0001 SEWA_N01_DSPSS1_SP22 9/12/2022 17:57 9/12/2022 17:59 ## 2 sewa0002 SEWA_N01_DSPSS1_SP22 9/14/2022 7:59 9/14/2022 8:01 ## 3 sewa0003 SEWA_N01_DSPSS1_SP22 9/14/2022 8:02 9/14/2022 8:02 ## 4 sewa0004 SEWA_N01_DSPSS1_SP22 9/15/2022 5:17 9/15/2022 5:17 ## 5 sewa0005 SEWA_N01_DSPSS1_SP22 9/16/2022 1:32 9/16/2022 1:33 # detection table dbGetQuery(wlf_cam_db, &quot;SELECT * FROM detection LIMIT 5;&quot;) ## detection_id sequence_id class order family genus species ## 1 cd00001 7446823 Mammalia Primates Hominidae Homo sapiens ## 2 cd00002 7446946 Mammalia Primates Hominidae Homo sapiens ## 3 cd00003 7447030 Mammalia Primates Hominidae Homo sapiens ## 4 cd00004 7447116 Mammalia Primates Hominidae Homo sapiens ## 5 cd00005 7447141 Mammalia Primates Hominidae Homo sapiens ## common_name age sex group_number ## 1 Human-Camera Trapper &lt;NA&gt; &lt;NA&gt; 1 ## 2 Human-Camera Trapper &lt;NA&gt; &lt;NA&gt; 1 ## 3 Human &lt;NA&gt; &lt;NA&gt; 1 ## 4 Human &lt;NA&gt; &lt;NA&gt; 1 ## 5 Human &lt;NA&gt; &lt;NA&gt; 1 "],["data-exploration.html", "3 Data exploration 3.1 Load package, database and tables 3.2 Exploratory summaries 3.3 Number of species 3.4 Number of detections", " 3 Data exploration Now that the database is created and loaded, we can explore and familiarize ourselves with trail camera data. 3.1 Load package, database and tables Load the tidyverse package to help with data exploration, along with the previous packages. Load the database and tables and assign them each to an object. library(DBI) library(RSQLite) library(tidyverse) wlf_cam_db &lt;- dbConnect(drv = RSQLite::SQLite(), &quot;../database/wlf_cam.db&quot;) project &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM project_name;&quot;) array &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM camera_array;&quot;) site &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM site_name;&quot;) deployment &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM deployment;&quot;) sequence &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM sequence;&quot;) detection &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM detection;&quot;) 3.2 Exploratory summaries Before diving into wildlife presence/absence and population trends, explore the following summary information about the trail cameras below. 3.2.1 Deployments per year We want to know how many cameras were deployed each year. n_cam &lt;- deployment %&gt;% mutate(year = year(mdy(start_date))) %&gt;% # acquire year from deployment date group_by(year) %&gt;% # group deployments by year tally # calculate number of cameras deployed per year n_cam ## # A tibble: 5 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 2019 65 ## 2 2020 61 ## 3 2021 67 ## 4 2022 116 ## 5 2023 93 3.2.2 Arrays with &gt; 8 cameras We want to know how many camera arrays had more than eight cameras deployed per survey period. Note that there is no foreign key directly connecting the array and deployment tables. We will need the site table to connect these these two tables. n_array &lt;- array %&gt;% left_join(site, by = &quot;array_name&quot;) %&gt;% # join site table to array using array_name left_join(deployment, by = &quot;site_id&quot;) %&gt;% # join deployment table to array using site_id mutate(year = year(mdy(start_date)), # acquire year from deployment date array_year = paste0(array_name, &quot;_&quot;, year)) %&gt;% # create new variable with array name and year group_by(array_year) %&gt;% tally %&gt;% # calculate number of cameras per array per year filter(n &gt; 8) %&gt;% # include arrays with more than 8 cameras tally # calculate number of arrays with &gt; 8 cameras deployed in a survey period n_array ## # A tibble: 1 × 1 ## n ## &lt;int&gt; ## 1 25 We can see that 25 camera array deployments had more than eight cameras. 3.2.3 Sites reused We want to know how many and which sites were reused. reused &lt;- site %&gt;% left_join(deployment, by = &quot;site_id&quot;) %&gt;% # join deployment table to site using site_id group_by(site_id) %&gt;% # group by site tally %&gt;% # calculate number of times each site is used filter(n &gt; 1) # include sites with more than one deployment n_reused &lt;- tally(reused) # calculate number of sites reused reused ## # A tibble: 40 × 2 ## site_id n ## &lt;chr&gt; &lt;int&gt; ## 1 DRPSS1 3 ## 2 DSPSS1 3 ## 3 IRPSS1 5 ## 4 JBPSS1 4 ## 5 LTPSS1 3 ## 6 LWPSS1 3 ## 7 MGPSS1 4 ## 8 NRPSS1 3 ## 9 OR_Forest_Oregon_State_University_22_ORSNAP07 2 ## 10 Oregon_Forest_Lesmeister_21_loc_01 4 ## # ℹ 30 more rows n_reused ## # A tibble: 1 × 1 ## n ## &lt;int&gt; ## 1 40 We can see that 40 sites were reused between 2019-2023 in Idaho, Washington and Oregon. 3.3 Number of species Now, let’s look at the species level. 3.3.1 By habitat We want to know how many species were detected in each habitat type. Similar to before, we will need to bring in a third table—sequence—to relate the detection and deployment tables. # filter out NA values for species sp_detect &lt;- detection[!is.na(detection$species), ] n_sp_habitat &lt;- sp_detect[sp_detect$species != &quot;sapiens&quot;, ] %&gt;% # filter out detections of humans filter(!grepl(&quot;Domestic&quot;, common_name)) %&gt;% # filter out domestic animals left_join(sequence, by = &quot;sequence_id&quot;) %&gt;% # join sequence table to detection using sequence_id left_join(deployment, by = &quot;deployment_id&quot;) %&gt;% # join deployment table to detection using deployment_id mutate(genus_species = paste0(genus, &quot; &quot;, species)) %&gt;% # create new variable with genus and species select(genus_species, habitat) %&gt;% # select variables genus_species and habitat group_by(habitat) %&gt;% # group by habitat tally n_sp_habitat ## # A tibble: 3 × 2 ## habitat n ## &lt;chr&gt; &lt;int&gt; ## 1 Anthropogenic 3538 ## 2 Forest 10467 ## 3 Grassland 371 3.3.2 By feature type We want to know how many species were detected near each feature type. Like the previous query, we will need the sequence table to relate the detection and deployment tables. # filter out NA values for species sp_detect &lt;- detection[!is.na(detection$species), ] n_sp_feature &lt;- sp_detect[sp_detect$species != &quot;sapiens&quot;, ] %&gt;% # filter out detections of humans filter(!grepl(&quot;Domestic&quot;, common_name)) %&gt;% # filter out domestic animals left_join(sequence, by = &quot;sequence_id&quot;) %&gt;% # join sequence table to detection using sequence_id left_join(deployment, by = &quot;deployment_id&quot;) %&gt;% # join deployment table to detection using deployment_id mutate(genus_species = paste0(genus, &quot; &quot;, species)) %&gt;% # create new variable with genus and species select(genus_species, feature_type) %&gt;% # select variables genus_species and feature_type group_by(feature_type) %&gt;% # group by feature_type tally n_sp_feature ## # A tibble: 6 × 2 ## feature_type n ## &lt;chr&gt; &lt;int&gt; ## 1 None 11219 ## 2 Other 763 ## 3 Road dirt 297 ## 4 Trail game 1239 ## 5 Trail hiking 730 ## 6 Water source 128 3.3.3 By habitat and feature type We want to know how many species were detected in each habitat type near each feature type. # filter out NA values for species sp_detect &lt;- detection[!is.na(detection$species), ] n_species &lt;- sp_detect[sp_detect$species != &quot;sapiens&quot;, ] %&gt;% # filter out detections of humans filter(!grepl(&quot;Domestic&quot;, common_name)) %&gt;% # filter out domestic animals left_join(sequence, by = &quot;sequence_id&quot;) %&gt;% # join sequence table to detection using sequence_id left_join(deployment, by = &quot;deployment_id&quot;) %&gt;% # join deployment table to detection using deployment_id mutate(genus_species = paste0(genus, &quot; &quot;, species)) %&gt;% # create new variable with genus and species select(genus_species, habitat, feature_type) %&gt;% # select variables genus_species, habitat, and feature_type group_by(habitat, feature_type) %&gt;% # group by habitat, then feature_type tally n_species ## # A tibble: 11 × 3 ## # Groups: habitat [3] ## habitat feature_type n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Anthropogenic None 2979 ## 2 Anthropogenic Trail game 257 ## 3 Anthropogenic Trail hiking 302 ## 4 Forest None 8240 ## 5 Forest Other 736 ## 6 Forest Road dirt 297 ## 7 Forest Trail game 766 ## 8 Forest Trail hiking 428 ## 9 Grassland Other 27 ## 10 Grassland Trail game 216 ## 11 Grassland Water source 128 3.4 Number of detections Let’s look at the individual level for wildlife detections. 3.4.1 By year We want to know how many individuals—known and unknown—were detected each year. wlf_detect &lt;- detection wlf_detect$species[is.na(wlf_detect$species)] &lt;- &quot;unknown&quot; # convert NA values to &quot;unknown&quot; n_detect_yr &lt;- wlf_detect[wlf_detect$species != &quot;sapiens&quot;, ] %&gt;% # filter out detections of humans filter(!grepl(&quot;Domestic&quot;, common_name)) %&gt;% # filter out domestic animals left_join(sequence, by = &quot;sequence_id&quot;) %&gt;% # join sequence table to detection using sequence_id mutate(year = year(mdy_hm(start_time))) %&gt;% # acquire year from start sequence select(group_number, year) %&gt;% # select variables group_number and year group_by(year) %&gt;% # group by year summarise(n = sum(group_number)) n_detect_yr ## # A tibble: 5 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 2019 4425 ## 2 2020 3780 ## 3 2021 1816 ## 4 2022 4696 ## 5 2023 4699 We want to know how many known individuals were detected each year. known_detect &lt;- detection[!is.na(detection$species), ] # filter out unknown (NA) detections n_known_yr &lt;- known_detect[known_detect$species != &quot;sapiens&quot;, ] %&gt;% # filter out detections of humans filter(!grepl(&quot;Domestic&quot;, common_name)) %&gt;% # filter out domestic animals left_join(sequence, by = &quot;sequence_id&quot;) %&gt;% # join sequence table to detection using sequence_id mutate(year = year(mdy_hm(start_time))) %&gt;% # acquire year from start sequence select(group_number, year) %&gt;% # select variables group_number and year group_by(year) %&gt;% # group by year summarise(n = sum(group_number)) n_known_yr ## # A tibble: 5 × 2 ## year n ## &lt;dbl&gt; &lt;int&gt; ## 1 2019 3432 ## 2 2020 2886 ## 3 2021 1618 ## 4 2022 3917 ## 5 2023 3841 3.4.2 By month We want to know how many individuals—known and unknown—were detected each month to assess at a more seasonal level. wlf_detect &lt;- detection wlf_detect$species[is.na(wlf_detect$species)] &lt;- &quot;unknown&quot; # convert NA values to &quot;unknown&quot; n_detect_m &lt;- wlf_detect[wlf_detect$species != &quot;sapiens&quot;, ] %&gt;% # filter out detections of humans filter(!grepl(&quot;Domestic&quot;, common_name)) %&gt;% # filter out domestic animals left_join(sequence, by = &quot;sequence_id&quot;) %&gt;% # join sequence table to detection using sequence_id mutate(month = month(mdy_hm(start_time))) %&gt;% # acquire month from start sequence select(group_number, month) %&gt;% # select variables group_number and year group_by(month) %&gt;% # group by year summarise(n = sum(group_number)) n_detect_m ## # A tibble: 4 × 2 ## month n ## &lt;dbl&gt; &lt;int&gt; ## 1 8 761 ## 2 9 8884 ## 3 10 8862 ## 4 11 909 We want to know how many known individuals were detected each year. known_detect &lt;- detection[!is.na(detection$species), ] # filter out unknown (NA) detections n_known_m &lt;- known_detect[known_detect$species != &quot;sapiens&quot;, ] %&gt;% # filter out detections of humans filter(!grepl(&quot;Domestic&quot;, common_name)) %&gt;% # filter out domestic animals left_join(sequence, by = &quot;sequence_id&quot;) %&gt;% # join sequence table to detection using sequence_id mutate(month = month(mdy_hm(start_time))) %&gt;% # acquire month from start sequence select(group_number, month) %&gt;% # select variables group_number and month group_by(month) %&gt;% # group by month summarise(n = sum(group_number)) n_known_m ## # A tibble: 4 × 2 ## month n ## &lt;dbl&gt; &lt;int&gt; ## 1 8 672 ## 2 9 7343 ## 3 10 6943 ## 4 11 736 3.4.3 By site We want to know which sites had the highest number of known individuals detected. Let’s focus on the top five sites. Note that we need to bring in the deployment and sequence tables to relate the site and detection tables. known_detect &lt;- detection[!is.na(detection$species), ] # filter out unknown (NA) detections known_detect &lt;- known_detect[known_detect$species != &quot;sapiens&quot;, ] # filter out human detections n_detect_site &lt;- site %&gt;% left_join(deployment, by = &quot;site_id&quot;) %&gt;% # join deployment table to site using site_id left_join(sequence, by = &quot;deployment_id&quot;) %&gt;% # join sequence table to site using deployment_id left_join(known_detect, by = &quot;sequence_id&quot;) %&gt;% # join detection table to site using sequence_id filter(!grepl(&quot;Domestic&quot;, common_name)) %&gt;% # filter out domestic animals select(group_number, site_id) %&gt;% # select variables group_number and month group_by(site_id) %&gt;% # group by month summarise(n = sum(group_number, na.rm = TRUE)) %&gt;% # calculate number of individuals detected per site arrange(desc(n)) # arrange in descending order of individuals detected head(n_detect_site, 5) # display the 5 sites with highest number of detections ## # A tibble: 5 × 2 ## site_id n ## &lt;chr&gt; &lt;int&gt; ## 1 IRPSS1 725 ## 2 JBPSS1 531 ## 3 LTPSS1 511 ## 4 RVPSS1 394 ## 5 DSPSS1 342 3.4.4 By site and month We want to know which sites had the highest number of known individuals detected in September and October. Again, let’s focus on the top five sites. We need to bring in the deployment table to relate the detection-sequence and site tables. known_detect &lt;- detection[!is.na(detection$species), ] # filter out unknown (NA) detections known_detect &lt;- known_detect[known_detect$species != &quot;sapiens&quot;, ] # filter out human detections n_detect &lt;- site %&gt;% left_join(deployment, by = &quot;site_id&quot;) %&gt;% # join deployment table to site table using site_id left_join(sequence, by = &quot;deployment_id&quot;) %&gt;% # join sequence table to site using deployment_id left_join(known_detect, by = &quot;sequence_id&quot;) %&gt;% # join detection table to site using sequence_id filter(!grepl(&quot;Domestic&quot;, common_name)) %&gt;% # filter out domestic animals mutate(month = month(mdy_hm(start_time))) %&gt;% # acquire month from start sequence filter(month %in% c(9, 10)) %&gt;% # only include detections from Sept and Oct select(group_number, month, site_id) %&gt;% # select variables group_number, month, and site_id group_by(site_id, month) %&gt;% # group by site_id, then by month summarise(n = sum(group_number, na.rm = TRUE)) # calculate number of individuals detected per site per month Sept &lt;- n_detect[n_detect$month == 9, ] %&gt;% arrange(desc(n)) # arrange in descending order of individuals detected Oct &lt;- n_detect[n_detect$month == 10, ] %&gt;% arrange(desc(n)) # arrange in descending order of individuals detected head(Sept, 5) ## # A tibble: 5 × 3 ## # Groups: site_id [5] ## site_id month n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 JBPSS1 9 355 ## 2 IRPSS1 9 310 ## 3 LTPSS1 9 298 ## 4 DSPSS1 9 204 ## 5 RVPSS1 9 190 head(Oct, 5) ## # A tibble: 5 × 3 ## # Groups: site_id [5] ## site_id month n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 IRPSS1 10 368 ## 2 LTPSS1 10 213 ## 3 SEWA_N01_LTPSS_SP20_OFF 10 203 ## 4 RVPSS1 10 195 ## 5 JBPSS1 10 168 "],["data-visualization.html", "4 Data visualization 4.1 Species in September and October 4.2 Detections across orders 4.3 Detections over time", " 4 Data visualization Begin visualizing trends seen in the camera trap data. First, connect to the database and load the tables and packages from before. We will also be using ggplot2. library(DBI) library(RSQLite) library(tidyverse) wlf_cam_db &lt;- dbConnect(drv = RSQLite::SQLite(), &quot;../database/wlf_cam.db&quot;) project &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM project_name;&quot;) array &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM camera_array;&quot;) site &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM site_name;&quot;) deployment &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM deployment;&quot;) sequence &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM sequence;&quot;) detection &lt;- dbGetQuery(wlf_cam_db, &quot;SELECT * FROM detection;&quot;) To use the same color scheme shown, run devtools::install_github(\"cdanielcadena/tanagR\") and load the package tanagR. library(tanagR) 4.1 Species in September and October We want to know the number of individuals in each species detected in September and October. There are many species observed throughout these data, so we will break down the detections as we go. # filter out NA values for species sp_detect &lt;- detection[!is.na(detection$species), ] sp_month &lt;- sp_detect[sp_detect$species != &quot;sapiens&quot;, ] %&gt;% # filter out detections of humans filter(!grepl(&quot;Domestic&quot;, common_name)) %&gt;% # filter out domestic animals left_join(sequence, by = &quot;sequence_id&quot;) %&gt;% # join sequence table to detection using sequence_id mutate(genus_species = paste0(genus, &quot; &quot;, species), # create new variable with genus and species month = month(mdy_hm(start_time), label = TRUE, abbr = FALSE)) %&gt;% # acquire month from start sequence filter(month %in% c(&quot;September&quot;, &quot;October&quot;)) %&gt;% # only include detections from Sept and Oct group_by(month, common_name) %&gt;% # group by month, then common_name select(order, family, genus_species, group_number, common_name, month) # select variables genus_species, group_number, and habitat 4.1.1 Species detected &gt; 100 times Let’s visualize this for species with more than 100 detections in September or October. mult_detect &lt;- sp_month %&gt;% group_by(month, common_name) %&gt;% summarize(n_individuals = sum(group_number)) %&gt;% # calculate number of individuals detected per species per month filter(n_individuals &gt; 100) # select species detected &gt; 100 times ggplot(mult_detect, aes(x = common_name, y = n_individuals, fill = month)) + geom_bar(stat = &quot;identity&quot;) + labs(x = &quot;Species detected&quot;, y = &quot;Number of individuals&quot;, fill = &quot;Month&quot;) + scale_fill_tanagr(palette_name = &quot;cyanerpes_cyaneus&quot;) + theme_classic() + theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) 4.1.2 Carnivora order detections Focusing on the order Carnivora, we want to visualize the number of individuals in each species detected in September and October. carnivora &lt;- sp_month[sp_month$order == &quot;Carnivora&quot;, ] %&gt;% # select species in order Carnivora group_by(month, common_name) %&gt;% summarize(n_individuals = sum(group_number)) # calculate number of individuals detected per species per month ggplot(carnivora, aes(x = common_name, y = n_individuals, fill = month)) + geom_bar(stat = &quot;identity&quot;) + labs(x = &quot;Species detected&quot;, y = &quot;Number of individuals&quot;, fill = &quot;Month&quot;) + scale_fill_tanagr(palette_name = &quot;ramphocelus_sanguinolentus&quot;) + theme_classic() + theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) 4.2 Detections across orders Many detections were only identified to the order level. Rather than looking at the species level, we want to visualize the number of individuals in each order detected in September and October. wlf_detect &lt;- detection wlf_detect$species[is.na(wlf_detect$species)] &lt;- &quot;unknown&quot; # convert NA values to &quot;unknown&quot; n_order &lt;- wlf_detect[wlf_detect$species != &quot;sapiens&quot;, ] %&gt;% # filter out detections of humans filter(!grepl(&quot;Domestic&quot;, common_name)) %&gt;% # filter out domestic animals left_join(sequence, by = &quot;sequence_id&quot;) %&gt;% # join sequence table to detection using sequence_id mutate(month = month(mdy_hm(start_time), label = TRUE, abbr = FALSE)) %&gt;% # acquire month from start sequence filter(month %in% c(&quot;September&quot;, &quot;October&quot;), # only include detections from Sept and Oct !is.na(order)) %&gt;% # remove NAs group_by(month, order) %&gt;% # group by month, then order summarise(n_individuals = sum(group_number)) # calculate number of individuals detected per order per month ggplot(n_order, aes(x = order, y = n_individuals, fill = month)) + geom_bar(stat = &quot;identity&quot;) + labs(x = &quot;Order detected&quot;, y = &quot;Number of individuals&quot;, fill = &quot;Month&quot;) + scale_fill_tanagr(palette_name = &quot;tangara_chilensis&quot;) + theme_classic() + theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) 4.3 Detections over time We want to visualize wildlife trends over time in a couple of ways. Let’s break this down again to help understand the bigger picture. detect_wlf &lt;- detection detect_wlf$term[!grepl(&quot;Domestic&quot;, detect_wlf$common_name)] &lt;- &quot;wildlife&quot; detect_wlf$term[detect_wlf$common_name != &quot;sapiens&quot;] &lt;- &quot;wildlife&quot; # define non-human and non-domestic life as wildlife in new column &#39;term&#39; detect_wlf$term[detect_wlf$species == &quot;sapiens&quot;] &lt;- &quot;human-domestic&quot; # define humans as human or domestic life detect_wlf$term[detect_wlf$common_name == &quot;Domestic Cat&quot;] &lt;- &quot;human-domestic&quot; # define domestic cats as human or domestic life detect_wlf$term[detect_wlf$common_name == &quot;Domestic Cattle&quot;] &lt;- &quot;human-domestic&quot; # define domestic cattle as human or domestic life detect_wlf$term[detect_wlf$common_name == &quot;Domestic Dog&quot;] &lt;- &quot;human-domestic&quot; # define domestic dogs as human or domestic life detect_wlf$term[detect_wlf$common_name == &quot;Domestic Horse&quot;] &lt;- &quot;human-domestic&quot; # define domestic horses as human or domestic life detect_wlf$term[detect_wlf$common_name == &quot;Domestic Sheep&quot;] &lt;- &quot;human-domestic&quot; # define domestic sheep as human or domestic life detect_wlf &lt;- detect_wlf[!is.na(detect_wlf$common_name), ] # remove wildlife undefined in the common_name sp_time &lt;- detect_wlf %&gt;% left_join(sequence, by = &quot;sequence_id&quot;) %&gt;% # join sequence table to detection using sequence_id left_join(deployment, by = &quot;deployment_id&quot;) %&gt;% # join deployment table to detection using deployment_id mutate(date = mdy(format(mdy_hm(start_time), &quot;%m-%d-%Y&quot;)), # acquire date from start sequence year = year(mdy_hm(start_time)), # acquire year from start sequence julian_day = date) # begin building julian day year(sp_time$julian_day) &lt;- 2000 # set year to be the same for all julian days 4.3.1 Wildlife detections over time We want to visualize the number of individuals detected over time and compare across years. wlf_time &lt;- sp_time[sp_time$term != &quot;human-domestic&quot;, ] %&gt;% group_by(year, julian_day) %&gt;% # group by year, then julian day summarise(n_individuals = sum(group_number)) # calculate number of individuals detected daily per year ggplot(wlf_time, aes(x = julian_day, y = n_individuals, color = as.factor(year))) + geom_point() + labs(x = &quot;Time&quot;, y = &quot;Number of individuals detected&quot;, color = &quot;Year&quot;) + scale_color_tanagr(palette_name = &quot;tangara_chilensis&quot;) + theme_classic() 4.3.2 Wildlife and human-domestic detections over time We want to visualize the number of individuals detected over time, along with the number of humans and domestic animals. We will first look at the year level. wlf_human_time &lt;- sp_time%&gt;% group_by(date, term) %&gt;% # group by date summarise(n_individuals = sum(group_number)) # calculate number of individuals detected daily across years ggplot(wlf_human_time, aes(x = date, y = n_individuals, color = term)) + geom_point() + labs(x = &quot;Time&quot;, y = &quot;Number of individuals detected&quot;, color = &quot;Detection type&quot;) + scale_color_tanagr(palette_name = &quot;tangara_chilensis&quot;) + theme_classic() Now, let’s look at a monthly level. wlf_human_julian &lt;- sp_time%&gt;% group_by(year, julian_day, term) %&gt;% # group by year, then julian day, then term summarise(n_individuals = sum(group_number)) # calculate number of individuals detected daily per year ggplot(wlf_human_julian, aes(x = julian_day, y = n_individuals, color = term)) + geom_point() + labs(x = &quot;Time&quot;, y = &quot;Number of individuals detected&quot;, color = &quot;Detection type&quot;) + scale_color_tanagr(palette_name = &quot;tangara_chilensis&quot;) + theme_classic() Surprisingly, wildlife detections do not appear to decrease as human and domestic animal detections increase. Rooney, B. 2024. Years of data collected by camera arrays. &lt;https://public.tableau.com/app/profile/brigit.rooney/viz/YearsofDataCollectedbyCameraArrays/Sheet6&gt;. Rooney, B., R. Kays, M. V. Cove, A. Jensen, B. R. Goldstein, C. Pate, P. Castiblanco, M. E. Abell, J. Adley, B. Agenbroad, et al. 2025a. SNAPSHOT USA 2019-2023: The first five years of data from a coordinated camera trap survey of the united states. Global Ecology and Biogeography 34:e13941. &lt;https://onlinelibrary.wiley.com/doi/full/10.1111/geb.13941&gt;. Rooney, B., W. McShea, R. Kays, and M. Cove. 2025b. SNAPSHOT USA 2019-2023: the first five years of data from a coordinated camera trap survey of the United States [Dataset]. Dryad. &lt;https://datadryad.org/dataset/doi:10.5061/dryad.k0p2ngfhn&gt;. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
